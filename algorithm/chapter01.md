# 동빈나 알고리즘 강의 Chapter 01.

> 동빈나 Youtube에 있는 Algorithm 강의 01

# 코딩 테스트

기업/기관에서 연수생을 선발하기 위한 문제 풀이 시험 (주로 공개 채용하는 기업에서 진행)

### 코딩 테스트 시행 이유

1. 문제 해결 역량 평가
2. 채점 시스템을 통해 응시자 수 효과적인 감소

## 코딩 테스트 유형

### 1. 온라인 코딩 테스트 (주)

인터넷을 통해 프로그래밍 역량 평가, 대체로 타인과 문제풀이를 공유하지 않는 선에서 인터넷 검색 허용하는 경우가 있음

### 2. 오프라인 코딩 테스트

시험장에 방문하여 시험 수행, 인터넷 검색이 허용되지 않으며, 회사에서 제공하는 컴퓨터 환경을 이용해 진행

### Online Judge

코딩 테스트 및 프로그래밍 대회에 나올 법한 문제를 시험해보는 시스템

- 해외

1. 코드포스(Codeforces) : www.codeforces.com
2. 탑코더(TopCoder) : www.topcoder.com
3. 릿코드(LeetCode) : leetcode.com
4. 코드셰프(CODECHEF) : www.codechef.com

- 국내

1. 백준 온라인 저지(BOJ) : www.acmicpc.net - 다수의 대기업 기출문제가 존재하며, 유형별로 풀기 가능, 국내 사용자들이 다수 존재 (추천)
2. 코드업(CodeUp) : codeup.kr - 처음 코딩테스트를 접할 때 좋음
3. 프로그래머스(Programmers) : programmers.co.kr - 인기 IT 대기업 문제 및 다양한 문제 포함 (추천)
4. SW Expert Academy : swexpertacademy.com

## 코딩 테스트 환경

### 1. (추천) 리플릿

- Link : https://repl.it/languages/python3

### 2. (초보용) 파이썬 튜터

- Link : http://pythontutor.com/visualize.html

## 소스 코드 관리

알고리즘 코딩 테스트 준비 과정에서 자신만의 소스 코드를 관리하는 것이 좋음 (라이브러리화)

## IT 기업 코딩 테스트 경향

대부분의 대기업은 알고리즘 코딩 테스트 시행

2~5시간 가량의 시간 동안 여러 개의 알고리즘 문제를 풀이함

### 가장 출제 빈도가 높은 유형

1. 그리디 알고리즘
2. 구현
3. DFS/BFS 기반 탐색

- 카카오의 경우 문제 풀이를 안내

# 알고리즘 성능 평가

__복잡도(Complexity)__ 는 알고리즘의 성능을 나타내는 척도

- 시간 복잡도 : 특정한 크기의 입력에 대하여 알고리즘의 수행 시간 분석
- 공간 복잡도 : 특정한 크기의 입력에 대해서 알고리즘의 메모리 사용량 분석

동일한 기능을 수행하는 알고리즘이 있다면, 일반적으로 _복잡도가 낮을수록 좋은 알고리즘_

## 빅오 표기법(Big-O Notation)

__가장 빠르게 증가하는 항__ 만을 고려하는 표기법으로, 함수의 상한만을 나타내게 된다.

예) 연산 횟수가 3N^3 + 5N^2 + 1,000,000인 알고리즘이 있을 때, 빅오 표기법에서는 차수가 가장 큰 항만을 남기므로 __O(N^3)__ 이 된다.

### 빅오 표기법 순위표

순위가 높을수록 좋음

|No.|순위|명칭|
|:---:|:---:|---|
|1|O(1)|상수 시간(Constant Time)|
|2|O(logN)|로그 시간(Log Time)|
|3|O(N)|선형 시간|
|4|O(NlogN)|로그 선형 시간|
|5|O(N^2)|이차 시간|
|6|O(N^3)|삼차 시간|
|7|O(2^n)|지수 시간|

예시 1)

N개의 데이터의 합을 계산하는 프로그램 예제

```python
array = [3,5,1,2,4] # 5개의 데이터 (N=5)
summary = 0 # 합계를 저장할 변수

# 모든 데이터를 하나씩 확인하며 합계를 계산
for x in array:
    summary += x

# 결과 출력
print(summary)
```

-> 수행 시간은 array의 길이(N)에 비례할 것임을 예측할 수 있다. 따라서 시간 복잡도는 __O(N)__ 이 된다.

예시 2)

2중 반복문을 사용하는 프로그램 예제

```python
array = [3,5,1,2,4] # 5개의 데이터 (N=5)

for i in array:
    for j in array:
        temp = i * j
        print(temp)
```

반복문과 그 안의 반복문 모두 array의 길이(N)에 따라 처리량이 달라지기 때문에 시간 복잡도는 __O(N^2)__ 가 된다.

다만, 모든 이중 반복문이 동일한 시간 복잡도를 갖지는 않는다.

## 알고리즘 설계 Tip

1. 일반적으로 CPU 기반 개인 컴퓨터 | 채점용 컴퓨터에서 연산 횟수가 _5억_ 을 넘어가는 경우
    - __C언어__ 기준 통상 __1~3초__ 소요
    - __Python__ 기준 통상 __5~15초__ 소요 _(단, PyPy의 경우 간혹 C언어보다 빠른 경우 존재)_
2. _O(N^3)_ 의 알고리즘의 경우 N의 값이 _5,000_ 을 넘어간다면?
3. 코딩 테스트 문제에서 시간 제한은 통상 __1~5초__ (명시되어 있지 않은 경우 5초 정도가 마지노선)

### 요구사항에 따라 적절한 알고리즘 설계

문제에서 가장 먼저 확인해야할 사항은 __시간 제한(수행시간 요구사항)__ 으로, 시간에 따라 적절하게 알고리즘을 선택하는 것이 중요

예) 시간 제한이 1초인 문제일 때 일반적인 기준

- N의 범위 500 : 시간 복잡도가 O(N^3)인 알고리즘 설계
- N의 범위 2,000 : 시간 복잡도가 O(N^2)인 알고리즘 설계
- N의 범위 100,000 : 시간 복잡도가 O(NlogN)인 알고리즘 설계
- N의 범위 10,000,000 : 시간 복잡도가 O(N)인 알고리즘 설계

### 알고리즘 문제 해결 과정

1. 지문 분석 및 컴퓨터적 사고를 통한 문제 분해
2. 요구사항(복잡도) 분석
3. 문제 해결을 위한 아이디어 도출
4. 소스 코드 설계 및 코딩

일반적으로 핵심 아이디어를 도출하면, 간결하게 소스 코드를 작성할 수 있는 형태로 출제

- 수행 시간 측정 소스 코드 예시 (Python)

    ```python
    import time
    start_time = time.time() # 측정 시작

    """
    프로그램 소스 코드
    """

    end_time = time.time()

    print("Time : ", end_time - start_time) # 수행 시간 출력
    ```