[< 목차 바로 가기](../README.md)

[Chapter 03. 이동 >](./chpater03.md)

# 동빈나 알고리즘 강의 Chapter 02.

> 그리디 & 구현

# 그리디 알고리즘 (탐욕법)

그디 알고리즘은 __현재 상황에서 지금 당장 좋은 것만 고르는 방법__ 으로, 일반적으로 문를 풀기 위한 최소한의 아이디어를 떠올릴 수 있는 능력을 요구

__정당성 분석__ 이 가장 중요한데, 단순하게 가장 좋아보이는 것을 반복적으로 선택해도 최적의 해를 구할 수 있는지 검토

일반적인 상황에서 그리디 알고리즘은 최적의 해를 보장할 수 없는 경우가 많지만, 코딩 테스트의 대부분 문제는 __그리디 알고리즘으로 얻은 해가 최적의 해가 되는 상황에서, 이를 추론__ 할 수 있어야 풀리도록 출제

### 예시 1) 거스름돈 문제

카운터에는 거스름돈으로 사용할 500원, 100원, 50원, 10원짜리 동전이 무한히 존재하는데,

손님에게 거슬러 주어야 할 돈이 N원일 때, 거슬러 주어야 할 동전의 최소 개수 (단, N은 항상 10의 배수)

최적의 해를 빠르게 구하기 위해서는 가장 큰 화폐 단위부터 거슬러 주면 된다. (500 -> 100 -> 50 -> 10 단위로 거슬러줄 수 있는만큼 거슬러줌)

1. (N = 1,260) 초기 단계 : 남은 돈 1,260원

2. 500원 * 2개 (1,000원) : 남은 돈 260원

3. 100원 * 2개 (200원) : 남은 돈 60원

4. 50원 * 1개 (50원) : 남은 돈 10원

5. 10원 * 1개 : 남은 돈 0원

- 정당성 분석

Q. 가장 큰 화폐 단위부터 돈을 거슬러주는 것이 최적의 해를 보장하는 이유?

A. 가지고 있는 동전 중에서 __큰 단위가 항상 작은 단위의 배수__ 이므로, __작은 단위의 동전들을 종합해 다른 해가 나올 수 없기 때문__

(만약, 화폐 단위가 500원, 400원, 100원이라면? : 기존의 정당성이 깨짐)

: 문제 풀이를 위한 최소한의 아이디어를 떠올리고 이것이 정당한지 검토

```python
n = 1260
count = 0

array = [500, 100, 50, 10] # 화폐 단위 큰 순으로 나열

for coin in array:
    count += n // coin # 해당 화폐로 거슬러 줄 수 있는 동전의 개수 Count (남은 금액을 해당 화폐 단위로 나눈 몫을 더함)

print(count)
```

- 시간 복잡도

화폐의 종류가 K라고 할 떄, 소스 코드의 시간 복잡도는 __O(K)__ (동전의 총 종류만큼 탐색을 진행하기 때문에)

### 예시 2) 1이 될 때까지...

어떠한 수 N이 1이 될 때까지 다음의 두 과정 중 하나를 반복적으로 선택하여 수행

1. N에서 1을 뺀다.
2. N을 K로 나눔 (단, N이 K로 나누어 떨어질 때만 선택 가능)

예를 들어, N=17, K=4 인 경우, 1번의 과정을 1번 수행하면 N=16, 이후에 2번의 과정을 2번 수행하면 N=1 (전체 실행 수 : 3)

N과 K가 주어졌을 때 N=1이 되기 위한 과정을 수행해야하는 최소 횟수

- 정당성 분석

주어진 N에 대하여 __최대한 많이 나누기__ 를 수행 : N이 아무리 커도 K로 나눈다면 N을 기하급수적으로 1에 가깝게 만들 수 있음

N의 값을 줄일 떄 __2 이상의 수로 나누는 작업__ 이 1을 빼는 작업보다 수를 훨씬 많이 줄이기 가능

- 내 풀이

```python
# N이 수가 낮기 때문에 이렇게 되긴 하지만,
# 시간 복잡도가 올라가는 것으로 보임
import sys

input_n_k = sys.stdin.readline().strip() # N, K 공백 구분하여 입력

n = int(input_n_k.split(" ")[0]) # N

k = int(input_n_k.split(" ")[1]) # K

count = 0

while True:
    # N == 1이라면 더이상 수행하지 않음
    if n == 1:
        break

    # N을 k로 나누었을 때 나머지가 0인 경우 k로 나눔
    if n % k == 0:
        n /= k
    # 아니라면 N에서 1을 뺌
    else:
        n -= 1

    # 연산을 수행했기 때문에 Count 1증가
    count += 1

print(count)
```

- 강의 풀이 (시간 복잡도 : __logN__ )

```python
"""
내 풀이대로 해도 되지만, 시간 복잡도가 올라간다.ㅜ
"""
n, k = map(int, input().split()) # 이를 활용해도 좋아보임 (input을 받고 int형으로 형변환하고 n, k로 선언 )

result = 0

while True:
    # N이 K로 나누어 떨어지는 수가 될 때까지 빼기
    # 만약에 N이 K로 나누어 떨어지지 않는다고 했을 때 가장 가까운 K로 나누어 떨어지는 수가 어떤 수인지 찾을 수 있음
    # N에서 1을 빼는 과정을 몇 번 반복해서 target이라는 값까지 만들 수 있고,
    # target이라는 값은 K로 나누어 떨어지는 수가 된다.
    target = (n // k) * k

    # 1을 빼는 연산을 몇 번 수행할지 한 번에 계산할 수 있음
    result += (n - target)

    n = target

    # N이 K보다 작다면 반복문을 탈출
    if n < k:
        break

    # 그렇지 않다면, K로 나누기
    result += 1
    n //= k

# 마지막으로 남은 수에 대하여 1씩 빼기
result += (n - 1)
print(result)
```

### 예시 3) 모험가 길드

> 다시 한 번 Review가 필요한 문제!!!

한 마을에 __모험가 N명__ 존재하고, 그들을 대상으로 '공포도'를 측정했는데, '공포도'가 높은 모험가는 쉽게 공포를 느껴 위험 상황에서 대처할 능력이 떨어짐

모험가 길드장인 동빈이는 모험가 그룹을 안전하게 구성하고자 __공포도가 X인 모험가는 반드시 X명 이상으로 구성한 모험가 그룹에 참여__ 해야 여행을 떠날 수 있도록 규정

최대 몇 개의 모험가 그룹을 만들 수 있는지 그룹 수의 최댓값을 구하기

첫째 줄에는 모험가 수 N, 둘째 줄부터는 각 모험의 공포도 값을 N이 하의 자연수 (공백 기준)

예) N = 5 각 모험가의 공포도가 2,3,1,2,2 인 경우

그룹 1에 공포도가 1,2,3인 모험가를 한 명씩 넣고, 그룹 2에 공포도가 2인 남은 두명을 넣게 되면 총 2개의 그룹을 만들 수 있음

또한, 몇 명의 모험가는 마을에 그대로 남아있어도 되기 때문에, 모든 모험가를 특정한 그룹에 넣을 필요는 없음

- 강의 풀이

```python
# 1. 오름차순 정렬 이후 공포도가 가장 낮은 모험가부터 하나씩 확인
# 2. 앞에서부터 공포도를 하나씩 확인하며, '현재 그룹에 포함된 모험가의수'가 '현재 확인하고 있는 공포도'보다 크거나 같다면 이를 그룹으로 설정
# - 공포도가 오름차순으로 정렬되어 있다는 점에서, 항상 최소한의 모험가 수만 포함하여 그룹을 결성

n = int(input()) # N
list_x = list(map(int, input().split())) # 공포도 X 목록
list_x.sort() # 오름차순 정렬

result = 0 # 총 그룹 수
count = 0 # 현재 그룹에 포함된 모험가 수

for x in list_x:
    count += 1 # 현재 그룹에 해당 모험가를 일단 포함

    # 현재 모험가의 수를 커버할 수 있는 공포도가 나와야 해당 조건문으로 들어간다.
    if count >= x: # 현재 그룹에 포함된 모험가의 수가 현재 공포도 이상이라면, 그룹 결성
        result += 1 # 총 그룹의 수 증가
        count = 0 # 현재 그룹에 포함된 모험가의 수 초기화

print(result) # 총 그룹의 수 출력
```

---

# 구현: 시뮬레이션과 완전 탐색

__구현__ : 머릿속에 있는 알고리즘을 소스 코드로 바꾸는 과정 (문제 -> 생각 -> 구현)

__풀이를 떠올리는 것은 쉽지만, 소스 코드로 옮기기 어려운 문제__

예시)

- 알고리즘은 간단한데 코드가 지나칠만큼 길어지는 문제 : 자기가 사용하는 프로그래밍 언어에 따라서 달라짐
- 실수 연산을 다루고, 특점 소수점 자리까지 출력해야 하는 문제
- 문자열을 특정한 기준에 따라서 끊어 처리해야하는 문제 (Python이 타언어 대비 사용하기 쉬움, 1-2번에 많이 출제)
- 적절한 라이브러리를 찾아서 해결해야하는 문제 (ex. 모든 순열, 모든 조합 찾기 등등...)

-> 이를 해결하기 위해서는 많은 연습을 통해 익혀야 함

일반적으로 구현 문제는 2차원 공간인 __행렬 (Matrix)__ 를 통해 풀게 된다.

__완전 탐색, 시뮬레이션 문제__ 를 접할 때 문제 내용을 확인해보면 __가장 왼쪽을 (0,0)__ 이라고 부르는 경우가 많음.

```
---->>>> y 축
| (0,0) | (0,1) | (0,2) | (0,3) | (0,4) |   |
| (1,0) | (1,1) | (1,2) | (1,3) | (1,4) |   |
| ... |                                     x
| (4,0) | (4,1) | (4,2) | (4,3) | (4,4) |   축
```

```python
for i in range(5):
    for j in range(5):
        print('(', i, ',', j, ')', end=' ')
    print()
```

2차원 공간에서의 __방향 벡터__ 가 자주 활용

예시) 특정한 캐릭터가 특정 위치에 존재하다가 상하좌우로 이동하는 경우의 문제

```python
# 동, 북, 서, 남
dx = [0, -1, 0, 1]
dy = [1, 0, -1, 0]

# 현재 위치
x, y = 2, 2

for i in range(4):
    # 다음 위치
    nx = x + dx[i]
    ny = y + dy[i]
    print(nx, ny)
```

### 예시 1) 상하좌우

여행가 A는 N * N 크기의 정사각형 공간 위에 있음.

이 공간은 1 * 1 크기의 정사각형으로 나누어져 있으며, 가장 왼쪽 위 좌표는 (1,1)이며, 가장 오른쪽 좌표는 (N, N)에 해당

여행가 A는 상,하,좌,우 방향으로 이동할 수 있으며, 시작 좌표는 항상 (1,1)

여행가 이동 계획서에는 하나의 줄에 띄어쓰기를 기준으로 하여 L, R, U, D 중 하나의 문자가 반복적으로 적혀있으며, 각 문자의 의미는 다음과 같다.

- L : 왼쪽으로 한 칸 이동
- R : 오른쪽으로 한 칸 이동
- U : 위로 한 칸 이동
- D : 아래로 한 칸 이동

여행가 A가 N * N 크기의 정사각형 공간을 벗어나는 움직임은 무시되는데, 예를 들어 (1, 1)의 위치에서 L | R 을 만나면 무시.

- 내 풀이

```python
n = int(input()) # N * N 배열

a_point = [1, 1]

list_moving_plan = input().split(" ") # 띄어 쓰기로 구분된 문자열 분할하여 List 객체에 저장

for moving_plan in list_moving_plan:
    if moving_plan == "L":
        # 더 이상 왼쪽으로 갈 수 없는 경우
        if a_point[1] == 1:
            continue

        a_point[1] -= 1 # 왼쪽으로 한 칸 이동
    elif moving_plan == "R":
        # 더 이상 오른쪽으로 갈 수 없는 경우
        if a_point[1] == n:
            continue

        a_point[1] += 1 # 오른쪽으로 한 칸 이동
    elif moving_plan == "U":
        # 더 이상 위로 갈 수 없는 경우
        if a_point[0] == 1:
            continue

        a_point[0] -= 1 # 위로 한 칸 이동
    elif moving_plan == "D":
        # 더 이상 아래로 내려갈 수 없는 경우
        if a_point[0] == n:
            continue

        a_point[0] += 1

print(a_point[0], a_point[1])
```

- 문제 풀이

```python
n = int(input()) # N 입력 받기
x, y = 1, 1 # 시작 지점
plans = input().split() # 이동 계획서 문자열 분리

# L, R, U, D 에 따른 좌표 이동 방향 정의
dx = [0, 0, -1, 1]
dy = [-1, 1, 0, 0]
move_types = ["L", "R", "U", "D"]

# 이동 계획 확인
for plan in plans:
    # 아래에서부터 내 풀이와 차이점이 발생
    for i in range(len(move_types)):
        # 문자가 이동 계획 문자와 일치한다면,
        if plan == move_types[i]:
            # move_types와 동일한 Index를 갖는 이유:
            # list들의 같은 index에 맞는 좌표 이동 값을 넣었기 때문
            nx = x + dx[i]
            ny = y + dy[i]

    # 공간을 벗어나는 경우 무시
    if nx < 1 or ny < 1 or nx > n or ny > n:
        continue

    # 실제 좌표 이동
    x, y = nx, ny

print(x, y)
```

### 예시 2) 시각

정수 N이 입력되면 00시 00분 00초부터 N시 59분 59초까지의 모든 시각 중에서 __3이 하나라도 포함되는 모든 경우의 수를 구하는 프로그램__ 작성

예를 들어 1을 입력했을 때 다음은 3이 하나라도 포함되어 있으므로, 세어야 하는 시각

- 00시 00분 03초
- 00시 13분 30초
- ...

세지 말아 할 시각

- 00시 02분 55초
- 01시 27분 45초

- 내 풀이

```python
n = int(input()) # 정수 N

count = 0 # 3이 하나라도 포함되는 경우의 수

# 00시 ~ N시까지 탐색
for hour in range(0, n+1):
    # 00분 ~ 59분까지 탐색
    for minute in range(0, 60):
        # 00초 ~ 59초까지 탐색
        for second in range(0, 60):
            # 시간 | 분 | 초 중에 3이라는 문자가 포함되어 있으면 count +1
            if '3' in str(second) or '3' in str(minute) or '3' in str(hour):
                count+=1

print(count)
```

- 문제 풀이

__가능한 모든 시각 경우의 수를 하나씩 세서 풀 수 있는 문제__

하루는 86,400초이므로, 00시 00분 00초부터 23시 59분 59초까지의 모든 경우의 수는 86,400가지. 따라서 1씩 증가시키면서 3이 하나라도 포함되어 있는지 확인

__완전 탐색(Brute Forcing)__ 문제 유형이라고 부름 (가능한 모든 경우의 수를 탐색하는 방법)

```python
h = int(input()) # H 입력 받기

count = 0
for i in range(h+1):
    for j in range(60):
        for k in range(60):
            # 매 시각 안에 3이 포함되어 있다면 카운트 증가
            if '3' in str(i) + str(j) + str(k):
                count += 1

print(count)
```

### 예시 3) 왕실의 나이트

행복 왕국의 왕실 정원은 체스판과 같은 __8 * 8__ 좌표 평면.

왕실 정원의 특정한 한 칸에 나이트가 서 있는데, 이동할 때 __L자 형태__ 로만 이동할 수 있으며, 정원 밖을 나갈 수 없음

나이트는 특정 위치에서 다음과 같은 2가지 경우로 이동 가능

1. __수평으로 두 칸__ 이동한 뒤 __수직으로 한 칸__ 이동
2. __수직으로 두 칸__ 이동한 뒤 __수평으로 한 칸__ 이동

8 * 8 좌표 평면에서 나이트의 위치가 주어졌을 때 나이트가 이동할 수 있는 경우의 수

왕실의 정원에서 행 위치를 표현할 때는 1부터 8까지 표현, 열 위치를 표현할 때는 a부터 h

예시) c2에 있을 때 이동할 수 있는 경우의 수는 __6가지__

- 내 풀이

```python
input_str = input()

row = ord(input_str[0]) - 96 # a(61) ~ h(68)에서 60 빼서 1~8로 만들기
column = int(input_str[1])

# 인덱스 0은 열을 더 많이 움직이는 경우, 1은 행을 더 많이 움직이는 경우
move_row = [2,1]
move_column = [1, 2]

count = 0

for i in range(2):
    # 열이 8*8 체스판 범위 안에 들어오는지 확인
    row_result = [True if row + move_row[i] < 9 else False, True if row - move_row[i] > 0 else False]

    # 행이 8*8 체스판 범위 안에 들어오는지 확인
    column_result = [True if column + move_column[i] < 9 else False, True if column - move_column[i] > 0 else False]

    for j in range(2):
        for k in range(2):
            # 둘 다 범위 안에 들어오면 Count +1
            if row_result[j] and column_result[k]:
                count += 1

print(count)
```

- 문제 풀이

요구사항대로 충실히 구현하면 되는 문제로, 나이트의 8가지 경로를 하나씩 확인하면서 매번 각 위치로 이동이 가능한지 확인

방향 벡터 정의

```python
input_data = input()

# 현재 위치한 열, 행 정의
row = int(input_data[1])
column = int(ord(input_data[0])) - int(ord('a')) + 1 # 앞으로 이렇게 정의해도 될 것 같아 보임

# 나이트가 이동할 수 있는 8가지 방향 정의
steps = [(-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2), (-1, 2), (-2, 1)]

# 8가지 방향에 대하여 각 위치로 이동 가능한지 확인
result = 0
for step in steps
    # 이동하고자 하는 위치 확인
    next_row = row + step[0]
    next_column = column + step[1]

    # 해당 위치로 이동이 가능하다면 카운트 증가
    if next_row >= 1 and next_row <= 8 and next_column >= 1 and next_column <= 8:
        result += 1

print(result)
```

### 문자열 재정렬

알파벳 대문자와 숫자(0~9)로만 구성된 문자열 입력

이 때 모든 알파벳을 오름차순으로 정렬하여 이어서 출력한 뒤에, 그 뒤에 모든 숫자를 더한 값을 이어서 출력

예) K1KA5CB7이라는 값이 들어오면 ABCKK13을 출력

- 내 풀이

```python
input_str = list(input()) # 문자열 List 객체로 변환

input_str.sort() # 오름차순 정렬

sum = 0

result = ''

for element in input_str:
    # Int 형변환 가능하면 sum 변수에 더함
    try:
        sum += int(element)
    # 형 변환이 불가하다면 element를 result에 추가
    except:
        result += element
        continue

# 문자 + 합 결과 조합
print(''.join(result) + str(sum))
```

- 문제 풀이

문자열이 입력되었을 때 문자를 하나씩 확인

숫자인 경우 따로 합계를 계산하며, 알파벳은 별도의 리스트에 저장해서, 결과적으로 리스트에 저장된 알파벳을 출력하고, 합계를 뒤에 붙여서 출력

```python
data = input()
result = []
value = 0

# 문자를 하나씩 확인하며
for x in data:
    # 알파벳인 경우 결과 리스트에 삽입
    if x.isalpha():
        result.append(x)
    else:
        value += int(x)

result.sort() # 알파벳을 오름차순 정렬

# 숫자가 하나라도 존재하는 경우 가장 뒤에 삽입
if value != 0:
    result.append(str(value))

# 최종 결과 출력
print(''.join(result))

```

---

## Reference.

- [동빈나 Youtube : 이코테 2021 1장](https://youtu.be/m-9pAwq1o3w?feature=shared)