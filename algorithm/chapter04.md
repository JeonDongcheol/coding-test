[< 목차 바로 가기](../README.md)

[Chapter 05. 이동 >](./chapter05.md)

# 동빈나 알고리즘 강의 Chapter 04.

> 정렬 알고리즘

## 정렬 알고리즘

__정렬(Sorting)__ 이란 _데이터를 특정한 기준에 따라 순서대로 나열하는 것_ 을 말하는데, 일반적으로 문제 상황에 따라서 적절한 정렬 알고리즘이 공식처럼 사용

ex) 데이터가 적을 때, 데이터가 많지만 특정 범위에서 한정되어 있을 때, 이미 특정 데이터가 정렬되어 있을 때...

__여러 개의 카드(데이터)를 정렬하는 방법__

```
[7] [5] [9] [0] [3] [1] [6] [2] [4] [8]
```

## 선택 정렬

처리되지 않은 데이터 중에서 __가장 작은 데이터를 선택하여 맨 앞에 있는 데이터와 바꾸는 것을 반복__

매번 현재 범위에서 가장 작은 데이터를 골라서 맨 앞으로 보내주는 방법

### 동작 예시

__[Step 0]__ 처리되지 않은 데이터 중 가장 작은 '0'을 선택해 가장 앞의 '7'과 바꿈

```
[0] [5] [9] [7] [3] [1] [6] [2] [4] [8]
---         ---
```

__[Step 1]__ 처리되지 않은 데이터 중 가장 작은 '1'을 선택해 가장 앞의 '5'와 바꿈

```
[0] [1] [9] [7] [3] [5] [6] [2] [4] [8]
    ---             ---
```

__[Step 2]__ 처리되지 않은 데이터 중 가장 작은 '2'를 선택해 가장 앞의 '9'와 바꿈

```
[0] [1] [2] [7] [3] [5] [6] [9] [4] [8]
        ---                 ---
```

__[Step 3]__ 처리되지 않은 데이터 중 가장 작은 '3'을 선택해 가장 앞의 '7'과 바꿈

```
[0] [1] [2] [3] [7] [5] [6] [9] [4] [8]
            --- ---
```

...

이러한 과정을 반복하여 나오는 결과는 다음과 같음

(마지막 데이터의 경우에는 정렬을 수행하지 않음)

```
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
```

탐색 범위는 __반복할 때마다 감소__, 가장 작은 데이터를 찾기 위해 _탐색 범위만큼 데이터를 하나씩 확인_ 하는 __선형 탐색__ 을 수행

이중 반복문을 통해 해당 과정을 수행

### 선택 정렬 소스 코드

```python
# 데이터
array = [7, 5, 9, 0, 3, 1, 6, 2, 4, 8]

# 탐색 범위
for i in range(len(array)):
    min_index = i # 가장 작은 원소의 Index

    # 탐색 범위 안에서 최소 값을 찾음
    for j in range(i + 1, len(array)):
        # 기존 최소 값보다 작다면
        if array[min_index] > array[j]:
            # 최소 값이 존재하는 Index 값을 변경
            min_index = j

    # 최종적으로 나온 두 원소의 위치를 바꿈
    array[i], array[min_index] = array[min_index], array[i]

print(array) # 출력
```

### 선택 정렬의 시간 복잡도

선택 정렬은 __N번__ 만큼 가장 작은 수를 찾아서 맨 앞으로 보내야하기 때문에, 사소한 오차를 제외하고 전체 연산 횟수는 다음과 같음

```
N + (N-1) + (N-2) + ... + 2
```

이는 `(N^2 + N - 2)/2` 로 표현할 수 있는데, BigO 표기법에 따라 __O(N^2)__ 으로 표현할 수 있음

---

## 삽입 정렬

처리되지 않은 데이터를 하나씩 골라 __적절한 위치에 삽입__ 하는 방식으로, 선택 정렬에 비해 _구현 난이도가 높지만,_ 일반적으로 _더 효율적_ 으로 동작

### 삽입 정렬 예시

__[Step 0]__ 첫 번째 데이터 '7'은 그 자체로 정렬이 되어 있다고 가정하고, 두 번째 데이터인 '5'가 어떤 위치로 들어갈지 판단

__'7'의 왼쪽으로 들어가거나, 오른쪽__ 으로 들어가는 경우만 존재

'7'보다 작기 때문에 '7'의 왼쪽으로 삽입

```
  [7] [5] [9] [0] [3] [1] [6] [2] [4] [8]
--- ---
```

__[Step 1]__ '9'가 어떤 위치로 들어갈지 [Step 1]의 방법과 마찬가지로 판단하는데, 이 경우에는 __'5'의 왼쪽, '5'와 '7' 사이, '7'의 오른쪽__ 으로 들어가는 경우가 존재

왼쪽 데이터인 '7'보다 작다면 위치를 바꾸고, 그렇지 않다면 해당 위치에 그대로 존재

```
  [5] [7] [9] [0] [3] [1] [6] [2] [4] [8]
--- --- ---
```

__[Step 2]__ '0'이 어떤 위치로 들어갈지 판단하는데, __'5'의 왼쪽부터 '9'의 오른쪽까지 들어가는 경우가 존재__ 하며, '9'보다 작기 때문에 '9'의 왼쪽으로 옮기고, '7'보다 작기 때문에 '7'의 왼쪽으로 옮기고, 마지막으로 '5'보다도 작기 때문에 '5'의 왼쪽으로 이동

```
  [0] [5] [7] [9] [3] [1] [6] [2] [4] [8]
--- --- --- ---
```

__[Step 3]__ '3'도 위와 마찬가지로 판단 진행

```
  [0] [3] [5] [7] [9] [1] [6] [2] [4] [8]
--- --- --- --- ---
```

이러한 과정을 반복하여 나오는 결과는 다음과 같음

(마지막 데이터의 경우에는 정렬을 수행하지 않음)

```
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
```

### 삽입 정렬 코드

```python
# 데이터
array = [7, 5, 9, 0, 3, 1, 6, 2, 4, 8]

# 첫 번째 원소는 건너뛰기 때문에 1번 Index부터 탐색
for i in range(1, len(array)):
    # Index i부터 1까지 1씩 감소하며 반복
    for j in range(i, 0, -1):
        # 타겟 Index의 값이 비교 대상 Index의 값보다 작다면,
        # 한 칸씩 왼쪽으로 이동
        if array[j] < array[j - 1]:
            array[j], array[j - 1] = array[j - 1], array[j]
        # 비교 대상 Index의 값보다 크거나 같다면,
        # 이동하지 않고, 다음 타겟 Index로 넘어감
        else:
            break

print(array)
```

### 삽입 정렬의 시간 복잡도

삽입 정렬의 시간 복잡도는 __O(N^2)__ 이며, 선택 정렬과 마찬가지로 __반복문이 두 번 중첩__ 되어 사용

삽입 정렬은 _현재 리스트의 데이터가 거의 정렬되어 있는 상태_ 에서 매우 빠르게 동작

최선의 경우에는 _O(N)_ 의 시간 복잡도를 가짐

---

## Reference.

- [동빈나 Youtube : 이코테 2021 4장](https://youtu.be/KGyK-pNvWos?feature=shared)