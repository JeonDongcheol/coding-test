[< 목차 바로 가기](../README.md)

[Chapter 05. 이동 >](./chapter05.md)

# 동빈나 알고리즘 강의 Chapter 04.

> 정렬 알고리즘

## 정렬 알고리즘

__정렬(Sorting)__ 이란 _데이터를 특정한 기준에 따라 순서대로 나열하는 것_ 을 말하는데, 일반적으로 문제 상황에 따라서 적절한 정렬 알고리즘이 공식처럼 사용

ex) 데이터가 적을 때, 데이터가 많지만 특정 범위에서 한정되어 있을 때, 이미 특정 데이터가 정렬되어 있을 때...

__여러 개의 카드(데이터)를 정렬하는 방법__

```
[7] [5] [9] [0] [3] [1] [6] [2] [4] [8]
```

## 선택 정렬

처리되지 않은 데이터 중에서 __가장 작은 데이터를 선택하여 맨 앞에 있는 데이터와 바꾸는 것을 반복__

매번 현재 범위에서 가장 작은 데이터를 골라서 맨 앞으로 보내주는 방법

### 동작 예시

__[Step 0]__ 처리되지 않은 데이터 중 가장 작은 '0'을 선택해 가장 앞의 '7'과 바꿈

```
[0] [5] [9] [7] [3] [1] [6] [2] [4] [8]
---         ---
```

__[Step 1]__ 처리되지 않은 데이터 중 가장 작은 '1'을 선택해 가장 앞의 '5'와 바꿈

```
[0] [1] [9] [7] [3] [5] [6] [2] [4] [8]
    ---             ---
```

__[Step 2]__ 처리되지 않은 데이터 중 가장 작은 '2'를 선택해 가장 앞의 '9'와 바꿈

```
[0] [1] [2] [7] [3] [5] [6] [9] [4] [8]
        ---                 ---
```

__[Step 3]__ 처리되지 않은 데이터 중 가장 작은 '3'을 선택해 가장 앞의 '7'과 바꿈

```
[0] [1] [2] [3] [7] [5] [6] [9] [4] [8]
            --- ---
```

...

이러한 과정을 반복하여 나오는 결과는 다음과 같음

(마지막 데이터의 경우에는 정렬을 수행하지 않음)

```
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
```

탐색 범위는 __반복할 때마다 감소__, 가장 작은 데이터를 찾기 위해 _탐색 범위만큼 데이터를 하나씩 확인_ 하는 __선형 탐색__ 을 수행

이중 반복문을 통해 해당 과정을 수행

### 선택 정렬 소스 코드

```python
# 데이터
array = [7, 5, 9, 0, 3, 1, 6, 2, 4, 8]

# 탐색 범위
for i in range(len(array)):
    min_index = i # 가장 작은 원소의 Index

    # 탐색 범위 안에서 최소 값을 찾음
    for j in range(i + 1, len(array)):
        # 기존 최소 값보다 작다면
        if array[min_index] > array[j]:
            # 최소 값이 존재하는 Index 값을 변경
            min_index = j

    # 최종적으로 나온 두 원소의 위치를 바꿈
    array[i], array[min_index] = array[min_index], array[i]

print(array) # 출력
```

### 선택 정렬의 시간 복잡도

선택 정렬은 __N번__ 만큼 가장 작은 수를 찾아서 맨 앞으로 보내야하기 때문에, 사소한 오차를 제외하고 전체 연산 횟수는 다음과 같음

```
N + (N-1) + (N-2) + ... + 2
```

이는 `(N^2 + N - 2)/2` 로 표현할 수 있는데, BigO 표기법에 따라 __O(N^2)__ 으로 표현할 수 있음

---

## 삽입 정렬

처리되지 않은 데이터를 하나씩 골라 __적절한 위치에 삽입__ 하는 방식으로, 선택 정렬에 비해 _구현 난이도가 높지만,_ 일반적으로 _더 효율적_ 으로 동작

### 삽입 정렬 예시

__[Step 0]__ 첫 번째 데이터 '7'은 그 자체로 정렬이 되어 있다고 가정하고, 두 번째 데이터인 '5'가 어떤 위치로 들어갈지 판단

__'7'의 왼쪽으로 들어가거나, 오른쪽__ 으로 들어가는 경우만 존재

'7'보다 작기 때문에 '7'의 왼쪽으로 삽입

```
  [7] [5] [9] [0] [3] [1] [6] [2] [4] [8]
--- ---
```

__[Step 1]__ '9'가 어떤 위치로 들어갈지 [Step 1]의 방법과 마찬가지로 판단하는데, 이 경우에는 __'5'의 왼쪽, '5'와 '7' 사이, '7'의 오른쪽__ 으로 들어가는 경우가 존재

왼쪽 데이터인 '7'보다 작다면 위치를 바꾸고, 그렇지 않다면 해당 위치에 그대로 존재

```
  [5] [7] [9] [0] [3] [1] [6] [2] [4] [8]
--- --- ---
```

__[Step 2]__ '0'이 어떤 위치로 들어갈지 판단하는데, __'5'의 왼쪽부터 '9'의 오른쪽까지 들어가는 경우가 존재__ 하며, '9'보다 작기 때문에 '9'의 왼쪽으로 옮기고, '7'보다 작기 때문에 '7'의 왼쪽으로 옮기고, 마지막으로 '5'보다도 작기 때문에 '5'의 왼쪽으로 이동

```
  [0] [5] [7] [9] [3] [1] [6] [2] [4] [8]
--- --- --- ---
```

__[Step 3]__ '3'도 위와 마찬가지로 판단 진행

```
  [0] [3] [5] [7] [9] [1] [6] [2] [4] [8]
--- --- --- --- ---
```

이러한 과정을 반복하여 나오는 결과는 다음과 같음

(마지막 데이터의 경우에는 정렬을 수행하지 않음)

```
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
```

### 삽입 정렬 코드

```python
# 데이터
array = [7, 5, 9, 0, 3, 1, 6, 2, 4, 8]

# 첫 번째 원소는 건너뛰기 때문에 1번 Index부터 탐색
for i in range(1, len(array)):
    # Index i부터 1까지 1씩 감소하며 반복
    for j in range(i, 0, -1):
        # 타겟 Index의 값이 비교 대상 Index의 값보다 작다면,
        # 한 칸씩 왼쪽으로 이동
        if array[j] < array[j - 1]:
            array[j], array[j - 1] = array[j - 1], array[j]
        # 비교 대상 Index의 값보다 크거나 같다면,
        # 이동하지 않고, 다음 타겟 Index로 넘어감
        else:
            break

print(array)
```

### 삽입 정렬의 시간 복잡도

삽입 정렬의 시간 복잡도는 __O(N^2)__ 이며, 선택 정렬과 마찬가지로 __반복문이 두 번 중첩__ 되어 사용

삽입 정렬은 _현재 리스트의 데이터가 거의 정렬되어 있는 상태_ 에서 매우 빠르게 동작

최선의 경우에는 _O(N)_ 의 시간 복잡도를 가짐

---

## 퀵 정렬

_기준 데이터_ 를 설정하고 그 __기준보다 큰 데이터와 작은 데이터의 위치를 바꾸는 방법__

일반적인 상황에서 가장 많이 사용되는 정렬 알고리즘 중 하나로, 병합 정렬과 더불어 대부분의 프로그래밍 언어의 정렬 라이브러리의 근간이 되는 알고리즘

가장 기본적인 퀵 정렬은 __첫 번째 데이터를 기준 데이터(Pivot)__ 로 설정

__왼쪽__ 에서부터 Pivot 값보다 _큰 값_ 을 선택하고, __오른쪽__ 에서부터는 Pivot 값보다 _작은 값_ 을 선택

### 퀵 정렬 동작 예시

```
[5] [7] [9] [0] [3] [1] [6] [2] [4] [8]
```

__[Step 0]__ 현재 피벗의 값은 '5'이며, 왼쪽에서부터 '5'보다 큰 데이터를 선택하므로 '7'이 되고, 오른쪽에서부터 '5'보다 작은 데이터를 선택하므로 '4'가 선택, 두 데이터의 위치를 서로 변경

```
  [5] [4] [9] [0] [3] [1] [6] [2] [7] [8]
Pivot ---                         ---
```

__[Step 1]__ 현재 피벗 값은 '5'이며, 왼쪽에서부터 '5'보다 큰 데이터를 선택하므로 '9'를 선택하고, 왼쪽에서부터 '5'보다 작은 데이터를 선택하므로 '2'를 선택, 두 데이터의 위치 변경

```
  [5] [4] [2] [0] [3] [1] [6] [9] [7] [8]
Pivot     ---                 ---
```

__[Step 2]__ 현재 피벗의 값은 '5'이며, 왼쪽에서부터 '5'보다 큰 데이터를 선택하므로 '6'을 선택하고, 오른쪽에서부터 '5'보다 작은 값을 선택하므로 '1'이 선택되는데, __위치가 엇갈리는 경우에는 '피벗'과 '작은 데이터'의 위치를 서로 변경__

```
# 위치가 엇갈렸기 때문에 피벗과 작은 데이터의 위치를 변경
[1] [4] [2] [0] [3] [5] [6] [9] [7] [8]
---                Pivot---
```

- __[분할 완료]__ 이제 '5'의 _왼쪽에 있는 데이터는 모두 5보다 작고_, _오른쪽에 있는 데이터는 모두 '5'보다 크다_ 는 특성을 갖게 되는데, 이렇게 _피벗을 기준으로 데이터 묶음을 나누는 작업_ 을 __분할 (Divide)__ 이라고 함

__[Step 3]__ 피벗이었던 '5'를 기준으로 왼쪽에 있는 데이터 배열을 기준으로 한 번 더 위의 작업을 수행

이처럼 퀵 정렬이 수행되는 과정이 재귀적으로 수행이 되며, 수행될 때마다 정렬이 되는 범위가 감소

```
  [1] [0] [2] [4] [3]
Pivot ---     ---

...
```

__[Step 4]__ 피벗이었던 '5'를 기준으로 으른쪽에 있는 데이터 배열을 기준으로 마찬가지로 퀵 정렬 수행

```
  [6] [9] [7] [8]
Pivot ---
```

### 퀵 정렬이 빠른 이유 (직관적인 이해)

이상적인 경우 분할이 절반씩 일어난다면, 전체 연산 횟수로 O(NlogN)을 기대할 수 있음

너비 * 높이 = N * logN = NlogN

### 퀵 정렬의 시간 복잡도

평균의 경우 __O(NlogN)__ 의 시간 복잡도를 가지는데, _최악의 경우_ 에는 __O(N^2)__ 의 시간 복잡도를 가짐

- 최악의 경우 : Pivot 값의 설정에 따라 다른데, 분할이 절반에 가깝게 이루어지는 것이 아닌, __한 쪽에 편향된 분할__ 이 이루어지는 경우

- 아래의 이미 정렬된 데이터에서 첫 번째 원소를 Pivot으로 설정하고 퀵 정렬을 수행한다면, 분할이 계속 오른쪽으로 편향되고 이에 따른 선형 탐색도 진행해야하기 때문에 시간 복잡도가 올라감

```
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
```

### 퀵 정렬 코드

```python
array = [5, 7, 9, 0, 3, 1, 6, 2, 4, 8]

def quick_sort(array, start, end):
    # 원소가 1개인 경우 종료
    if start >= end:
        return

    pivot = start # Pivot은 첫 번째 원소

    left = start + 1 # 왼쪽은 Pivot에서 바로 오른쪽
    right = end # 오른쪽은 데이터의 마지막 원소

    # left가 가리키는 index보다 right가 가리키는 index 값이 더 작다면,
    # 엇갈렸다고 판단하고 반복문 탈출
    while(left <= right):
        # Pivot보다 큰 데이터를 찾을 때까지 반복 (left를 1씩 증가시켜서 이동)
        while (left <= end and array[left] <= array[pivot]):
            left += 1

        # Pivot보다 작은 데이터를 찾을 때까지 반복 (left를 1씩 감소시켜서 이동)
        while(right > start and array[right] >= array[pivot]):
            right -= 1

        # 엇갈렸다면, 작은 데이터와 Pivot을 교체
        if (left > right):
            array[right], array[pivot] = array[pivot], array[right]
        # 엇갈리지 않았다면, 작은 데이터와 큰 데이터를 교체
        else:
            array[left], array[right] = array[right], array[left]

    # 분할 이후 왼쪽 부분과 오른쪽 부분에서 각각 재귀적으로 정렬 수행
    quick_sort(array, start, right - 1)
    quick_sort(array, right + 1, end)

quick_sort(array, 0, len(array) - 1)

print(array)
```

### 퀵 정렬 소스코드 (파이썬의 장점을 살린 방법)

```python
# List Comprehension을 이용한 퀵 정렬
array = [5, 7, 9, 0, 3, 1, 6, 2, 4, 8]

def quick_sort(array):
    # 리스트가 하나 이하의 원소만을 담고 있다면 종료
    if len(array) <= 1:
        return

    pivot = array[0] # Pivot은 첫 번째 원소
    array_exclude_pivot = array[1:] # Pivot을 제외한 List 추출

    # Pivot을 제외한 원소들 중에서 Pivot보다 작은 원소는 left_side로, 큰 원소는 right_side로 나눔
    left_side = [x for x in array_exclude_pivot if x <= pivot] # 분할된 왼쪽 부분
    right_side = [x for x in array_exclude_pivot if x > pivot] # 분할된 오른쪽 부분

    # 분할 이후 왼쪽 부분과 오른쪽 부분에서 각각 정렬을 수행하고, 전체 List 합쳐서 반환
    return quick_sort(left_side) + [pivot] + quick_sort(right_side)

print(quick_sort(array))
```

---

## 계수 정렬

특정한 조건이 부합할 때만 사용할 수 있지만, __매우 빠르게 동작__ 하는 정렬 알고리즘

조건 : 데이터의 크기 범위가 제한되어 __정수 형태로 표현__ 할 수 있을 때

데이터의 개수가 N, 데이터(양수) 중 최댓값이 K일 때 최악의 경우에도 시간 복잡도 __O(N + K)__ 를 보장

### 퀵 정렬 동작 예시

__[Step 0]__ 가장 작은 데이터부터 가장 큰 데이터까지의 범위가 모두 담길 수 있도록 List 생성

- 정렬할 데이터 : 7, 5, 9, 0, 3, 1, 6, 2, 9, 1, 4, 8, 0, 5, 2

```
# 각 Index가 데이터의 값에 해당
# 각 데이터가 총 몇 번씩 등장했는지 개수를 측정
Index 0 1 2 3 4 5 6 7 8 9
Count 0 0 0 0 0 0 0 0 0 0
```

__[Step 1]__ 데이터를 하나씩 확인하며 데이터의 값과 동일한 Index의 데이터를 1씩 증가

- 정렬할 데이터 : __7__, 5, 9, 0, 3, 1, 6, 2, 9, 1, 4, 8, 0, 5, 2

```
Index 0 1 2 3 4 5 6 7 8 9
Count 0 0 0 0 0 0 0 1 0 0
```

__[Step 2]__ 데이터를 하나씩 확인하며 데이터의 값과 동일한 Index의 데이터를 1씩 증가

- 정렬할 데이터 : 7, __5__, 9, 0, 3, 1, 6, 2, 9, 1, 4, 8, 0, 5, 2

```
Index 0 1 2 3 4 5 6 7 8 9
Count 0 0 0 0 0 1 0 1 0 0
```

__[Step 3]__ 데이터를 하나씩 확인하며 데이터의 값과 동일한 Index의 데이터를 1씩 증가

- 정렬할 데이터 : 7, 5, __9__, 0, 3, 1, 6, 2, 9, 1, 4, 8, 0, 5, 2

```
Index 0 1 2 3 4 5 6 7 8 9
Count 0 0 0 0 0 1 0 1 0 1
```

...

__[Step 15]__ 위의 과정을 반복하여 결과적으로 최종 List에는 각 데이터가 몇 번씩 등장했는지 그 횟수가 기록

- 정렬할 데이터 : 7, 5, 9, 0, 3, 1, 6, 2, 9, 1, 4, 8, 0, 5, __2__

```
Index 0 1 2 3 4 5 6 7 8 9
Count 2 2 2 1 1 2 1 1 1 2
```

__[Step 16]__ 결과를 확인할 때는 List의 첫 번째 데이터부터 하나씩 그 값만큼 반복하여 Index 출력

```
Index 0 1 2 3 4 5 6 7 8 9
Count 2 2 2 1 1 2 1 1 1 2
```

- 출력 결과 : 정렬이 수행된 결과와 동일하게 수행

```
0 0 1 1 2 2 3 4 5 5 6 7 8 9 9
```

### 계수 정렬 소스코드

```python
# 모든 원소의 값이 0보다 크거나 같다고 가정
array = [7, 5, 9, 0, 3, 1, 6, 2, 9, 1, 4, 8, 0, 5, 2]

# 모든 범위를 포함하는 List 선언 (모든 값은 0으로 초기화)
count = [0] * (max(array) + 1)

# 각 데이터에 해당하는 Array Index의 데이터 값 1증가
for i in range(len(array)):
    count[array[i]] += 1

# List에 누적된 정렬 정보 확인
# 반복문을 두 번 돌리는 이유는 Array의 Index 안의 값만큼 Index를 출력해야하기 때문임
for i in range(len(count)):
    for j in range(count[i]):
        print(i, end=' ') # 띄워쓰기를 구분으로 등장한 횟수만큼 Index의 값 출력
```

### 계수 정렬의 복잡도 분석

계수 정렬의 시간 복잡도와 공간 복잡도는 모두 __O(N + K)__ 인데, 경우에 따라서 심각한 비효율 성을 초래할 수 있음

ex) 데이터가 0과 999,999로 단 2개만 존재하는 경우 > 없는 데이터에 대해서도 Index를 돌게 된다.

계수 정렬은 __동일한 값을 가지는 데이터가 여러 개__ 등장할 때 효과적으로 사용 가능

ex) 성적의 경우 100점을 맞은 학생이 여러 명일 수 있기 때문에 계수 정렬이 효과적

---

## 정렬 알고리즘 비교

4가지의 정렬 알고리즘 비교표

|정렬 알고리즘|평균 시간 복잡도|공간 복잡도|특징|
|:---:|:---:|:---:|---|
|선택 정렬|O(N^2)|O(N)|아이디어가 매우 간단, 구현이 쉬움|
|삽입 정렬|O(N^2)|O(N)|데이터가 거의 정렬되어 있을 때 빠름|
|퀵 정렬|O(NlogN)|O(N)|대부분의 경우에 가장 적합하고, 충분히 빠름, 구현 방식에 따라 시간 복잡도가 O(N^2)|
|계수 정렬|O(N + K)|O(N + K)|데이터의 크기가 한정적인 경우에만 사용 가능하지만, 속도가 매우 빠름|

추가로, 대부분의 프로그래밍 언어에서 지원하는 _표준 정렬 라이브러리_ 는 __최약의 경우__ 에도 __O(NlogN)__ 을 보장하도록 설계되어 있음

### 선택 정렬과 기본 정렬 라이브러리 수행 시간 비교

- 선택 정렬 (수행 결과 : 약 8초)

  ```python
  from random import randint
  import time

  # 배열에 10,000개 정수 삽입
  array = []

  for _ in range(10_000):
      # 1부터 100 사이의 랜덤한 정수
      array.append(randint(1, 100))

  # 선택 정렬 프로그램 성능 측정을 위한 시간 값
  start_time = time.time()

  # 선택 정렬 코드
  for i in range(len(array)):
      min_index = i # 가장 작은 원소의 Index

      for j in range(i + 1, len(array)):
          if array[min_index] > array[j]:
              min_index = j

      array[i], array[min_index] = array[min_index], array[i]

  # 측정 종료 시간
  end_time = time.time()

  # 수행 시간 결과 출력
  print("선택 정렬 성능 측정 결과 : ", (end_time - start_time))
  ```

- 기본 정렬 라이브러리 (수행 결과 : 약 0.001초)

  ```python
  from random import randint
  import time

  # 배열에 10,000개 정수 삽입
  array = []

  for _ in range(10_000):
      # 1부터 100 사이의 랜덤한 정수
      array.append(randint(1, 100))

  # 기본 정렬 라이브러리 성능 측정을 위한 시작 시간 설정
  start_time = time.time()

  # 기본 정렬 라이브러리 사용
  array.sort()

  # 측정 종료
  end_time = time.time()

  # 수행 시간 출력
  print("기본 정렬 라이브러리 성능 측정 결과 : ", (end_time - start_time))
  ```

---

## 정렬 알고리즘 문제풀이

### 예시 1) 두 배열의 원소 교체

동빈이는 __2개의 배열 A, B__ 를 갖고 있는데, 두 배열은 __N개의 원소__ 로 구성되어 있으며, 배열의 원소는 모두 __자연수__

__최대 K번의 바꿔치기 연산을 수행__ 할 수 있는데, 바꿔치기 연산이란, 배열 A에 있는 원소 하나와 배열 B에 있는 원소 하나를 골라서 두 원소를 서로 바꾸는 것

최종 목표는 __배열 A의 모든 원소의 합이 최대__ 가 되도록 함

N, K, 배열 A&B의 정보가 주어졌을 때, 최대 K 번의 바꿔치기 연산을 수행하여 만들 수 있는 배열 A의 모든 원소의 함의 최댓 값을 출력

예시) N = 5, K = 3이고, 배열 A, B의 정보는 아래와 같음

```
A = [1, 2, 5, 4, 3]
B = [5, 5, 6, 6, 5]
```

이 경우, 3번의 연산을 수행할 수 있음
- 연산 1 : 배열 A의 원소 '1'과 배열 B의 원소 '6'을 교환
- 연산 2 : 배열 A의 원소 '2'와 배열 B의 원소 '6'을 교환
- 연산 3 : 배열 B의 원소 '3'과 배열 B의 원소 '5'를 교환

3 번의 연산 후 배열 A, B의 구성

```
A = [6, 6, 5, 4, 5]
B = [3, 5, 1, 2, 5]
```

이 때 배열 A의 모든 원소의 합은 26이 되며, 이보다 더 합을 크게 만들 수 없음

- 첫 번째 줄 : N, K가 공백을 기준으로 입력 (1 <= N <= 100,000, 0 <= K <= N)

- 두 번째 줄 : 배열 A의 원소들이 공백을 기준으로 입력 (모든 원소는 10,000,000보다 작은 자연수)

- 세 번째 줄 : 배열 B의 원소들이 공백을 기준으로 입력 (모든 원소는 10,000,000보다 작은 자연수)

- 출력 조건 : 최대 K번의 바꿔치기 연산을 수행하여 만들 수 있는 배열 A의 모든 원소의 합의 최댓값을 출력

- 내 풀이

```python
n, k = map(int, input().split(" ")) # N, K 입력

a = list(map(int, input().split(" "))) # 배열 A
b = list(map(int, input().split(" "))) # 배열 B

# A, B 정렬
a.sort()
b.sort()

# A는 왼쪽부터, B는 오른쪽부터 비교하면서 숫자 교체
for i in range(n-1):
    # 최대 바꿔치기 횟수를 넘으면 더 이상 바꿔치기 하지 않음
    if k <= 0:
        break

    # A의 원소가 B의 원소보다 크다면 더 이상 바꿔치기 하지 않음
    if a[i] >= b[n-i-1]:
        break

    # A의 원소와 B의 원소 바꿔치기
    a[i], b[n -i-1] = b[n-i-1], a[i]

    k -= 1 # K 1 차감

sum = 0

for i in a:
    sum += i

print(sum)
```

- 문제 풀이

  - __핵심 아이디어__ : 매번 배열 A에서 가장 작은 원소를 골라서, 배열 B에서 가장 큰 원소와 교체

    가장 먼저 배열 A, B에 대하여, A는 오름차순, B는 내림차순 정렬을 수행

    이후에 두 배열의 원소를 첫 번째 Index부터 차례대로 확인하면서 A의 원소가 B의 원소보다 작을 때만 바꿔치기 수행

    최대 100,000개까지 입력될 수 있으므로, 최악의 경우 __O(NlogN)__ 을 보장하는 정렬 알고리즘 사용

```python
n, k = map(int, input().split()) # N, K 입력 받기

a = list(map(int, input().split())) # 배열 A 입력
b = list(map(int, input().split())) # 배열 B 입력

a.sort() # 배열 A 오름차순 정렬
b.sort(reverse=True) # 배열 B 내림차순 정렬

# 첫 번째 Index부터 확인하여 두 배열의 원소를 최대 K번 비교
for i in range(k):
    # A의 원소가 B의 원소보다 작은 경우
    if a[i] < b[i]:
        # 두 원소 바꿔치기
        a[i], b[i] = b[i], a[i]
    # A의 원소가 B의 원소보다 크거나 같다면, 더 이상 비교하여 바꿔치기 할 필요가 없음
    else:
        break

print(sum(a))
```

---

## Reference.

- [동빈나 Youtube : 이코테 2021 4장](https://youtu.be/KGyK-pNvWos?feature=shared)